package com.dlouvton.badger.tracker;

import java.io.IOException;
import java.lang.reflect.Field;

import com.mongodb.BasicDBObject;
import com.mongodb.DBObject;
import com.dlouvton.badger.provisioner.VagrantProvisioner;
import com.dlouvton.badger.util.MongoManager;
import com.dlouvton.badger.util.Utils;

/**
 * Implementation of the Tracker interface - Using MongoDB as a persistence layer
 * When a class extends this Tracker, it's public fields may be persisted on Mongo
 */
abstract public class MongoTracker implements Tracker{
	private static BasicDBObject data;
	private String trackerName;
	private String identifier;
	public static boolean skipUpload = false;

	/**
	 * constructor:
	 * generates a unique identifier that is being inserted to the Mongo document. 
	 * The identifier is used to collate with other document (sort of primary key for the document)
	 * initializes a BasicDBObject.
	 * Uses the underlying class name as the tracker name
	 */
	public MongoTracker() {		
		// use the underlying class name as the tracker name
		trackerName = getClass().getSimpleName();
		// unique identifier to be inserted into the collection
		identifier = String.valueOf(System.currentTimeMillis());
		data = new BasicDBObject("_run_id", identifier);
	}

	/**
	 * get unique identifier of the document
	 * @return String identifier
	 */
	public String getIdentifier() {
		return identifier;
	}

	/**
	 * get usage data object
	 * @return DBObject a json object that can be inserted to MongoDB
	 */
	public DBObject getData() {
		return data;
	}

	/**
	 * puts a key-value pair (adds or updates an existing pair) into data document, if value is not null
	 * @param key
	 * @param value
	 */
	public void put(String key, Object value) {
		if (value != null) {
			data.put(key, value.toString());
		}
	}

	/**
	 * append data with new key-value pairs, if value is not null
	 * @param newData key value pairs
	 */
	public void appendData(Object newData) {
		if (skipUpload) {
			return;
		}
		try {
			VagrantProvisioner.getMongoManager().updateDocument(
					(BasicDBObject) newData, MongoManager.USAGE_DB_NAME, trackerName);
		} catch (IOException e) {
			Utils.logSevere(e, "Error updating tracking data to Mongo DB");
		}
	}
	
	/**
	 * dump key-value pairs of all public fields of underlying class into data, if value is not null
	 */
	@Override
	public void dumpFields() {
		for (Field publicField : getClass().getFields()) {
			try {
				put(publicField.getName(),publicField.get(this));
			} catch (IllegalArgumentException | IllegalAccessException e) {
				Utils.logSevere(e, "Error accessing public fields of class "+this.getClass().getName());
			}
		}
			
	}
	
	/**
	 * dump public fields from underlying class to document, and
	 * upload usage data to mongo, if it was not generated by unit tests
	 */
	public void uploadData() {
		dumpFields();
		if (skipUpload) {
			return;
		}		
		try {			
			VagrantProvisioner.getMongoManager().postDocument(data, MongoManager.USAGE_DB_NAME, trackerName);
		} catch (IOException e) {
			Utils.logSevere(e, "Error uploading tracking data to Mongo DB");
		}
	}
	
	/**
	 * update the public fields on the current document
	 */
	public void updateData() {
		dumpFields();
		if (skipUpload) {
			return;
		}		
		try {			
			VagrantProvisioner.getMongoManager().updateDocument(data, MongoManager.USAGE_DB_NAME, trackerName);
		} catch (IOException e) {
			Utils.logSevere(e, "Error updating tracking data on Mongo DB");
		}
	}
	
	/** 
	 * returns the last document created, uploaded or updated
	 * note that this method is *static* to allow verifications after an environment is destroyed
	 * @return DBObject a json object that can be inserted to MongoDB
	 */
	public static DBObject getLastDocument() {
		return data;
	}
	
	/**
	 * use when document is generated by unit tests, skip uploading/updating the database
	 */
	public static void skipUpload() {
		skipUpload = true;
	}
}
